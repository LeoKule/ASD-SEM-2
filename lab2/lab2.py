def matrix_to_graph(matrix):
    V = list(range(len(matrix)))  # Список вершин, V = [0, 1, 2, ..., n-1], где n - количество вершин в графе
    E = []  # Пустой список для хранения ребер

    for i in range(len(matrix)):  # Проходим по всем строкам матрицы
        for j in range(len(matrix[i])):  # Проходим по всем элементам строки
            if matrix[i][j] == 1:  # Если элемент равен 1, это означает, что есть ребро между вершинами i и j
                E.append((i, j))  # Добавляем ребро в список ребер

    return (V, E)  # Возвращаем кортеж из списка вершин и списка ребер



def bfs(G, source, destination):
    V, E = G  # Распаковываем граф на список вершин V и список ребер E
    d = [float('inf')] * len(V)  # Инициализируем список расстояний значением бесконечность
    d[source] = 0  # Расстояние от начальной вершины до самой себя равно 0
    Q = [source]  # Инициализируем очередь с начальной вершиной

    while Q:  # Пока очередь не пуста
        u = Q.pop(0)  # Извлекаем вершину из начала очереди
        for edge in E:  # Проходим по всем ребрам графа
            if edge[0] == u:  # Если вершина u является началом ребра
                v = edge[1]  # Получаем конечную вершину ребра
                if d[v] == float('inf'):  # Если вершина v еще не посещена
                    d[v] = d[u] + 1  # Обновляем расстояние до вершины v
                    Q.append(v)  # Добавляем вершину v в очередь

    return d[destination]  # Возвращаем расстояние до конечной вершины



with open("matrix.txt") as f:
    matrix = f.readlines()  # Читаем все строки файла
    matrix = [i.strip().split() for i in matrix]  # Разделяем строки на отдельные элементы и удаляем пробелы
    matrix = [list(map(int, i)) for i in matrix]  # Преобразуем элементы в целые числа

    graph = matrix_to_graph(matrix)  # Преобразуем матрицу смежности в граф
    print(bfs(graph, 0, 5))  # Выводим длину кратчайшего пути от вершины 0 до вершины 5

